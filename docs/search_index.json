[["how-much-r-do-i-need-to-know-to-pass.html", " 2 How much R do I need to know to pass? 2.1 How to use the PA R cheat sheets? 2.2 Example: SOA PA 6/16/20, Task 8 2.3 Example 2 - Data exploration", " 2 How much R do I need to know to pass? This is a communication exam because 30-40% of the points are based on your writing and data storytelling quality. You do not need to become an R expert for this exam. While you are expected to develop a basic familiarity with R, the .Rmd template will provide you with the vast majority of the R commands needed. You will need to practice taking code templates and adjusting them to the specific variables and formulas you need. The most difficult coding questions will be during data exploration. These will ask you to Use basic mathematical operators and functions such as exp() and log() Select, modify, and summarize data in a dataframe Display data from a dataframe in common types of plots, using ggplot2 When fitting predictive models, you will also need to Modify or add a formula or other parameters to model-fitting functions like glm() and rpart() Extract and displaying results from a fitted predictive model You are not expected to construct loops, write functions, or use other programmatic techniques with R. The scope is limited to single-line commands. You will have two cheat sheets for data visualization and base R. You can use this in your study to become familiar with how to find the R code quickly. These cheat sheets that the SOA gives you were designed by the RStudio team for everyone who uses R, and so we have gone through and removed the parts that you will not need to learn. For example, no one will be making new types of ggplot graphs under the “graphical primitives” section, which has been blocked out. Enroll in either of our online courses to get our simplified Base R cheat sheet and tutorial. 2.1 How to use the PA R cheat sheets? Be observant and expect to spend twice as long explaining what your code is doing as you write the code itself. A few observations are based on the organization your .Rmd file, although you do not need this to read like an essay. The vast majority of your time will be spent on your Word document. The June 16 2020 Project Statement has this under “General information for candidates.” Each task will be graded on the quality of your thought process, added or modified code, and conclusions At a minimum, you must submit your completed report template and an .Rmd file that supports your work. Graders expect that your .Rmd code can be run from beginning to end. The code snippets provided should either be commented out or adapted for execution. Ensure that it is clear where in the code each of the tasks is addressed. In other words, the results of your report must be consistent with what the grading team finds when they run your .Rmd file. 2.2 Example: SOA PA 6/16/20, Task 8 This question is from the June 16, 2020 exam. You can see that significantly only minor code changes need to be made. The remainder of this question consists of a short-answer response. This is very typical of Exam PA. Already enrolled? Watch the full video: Practice Exams | Practice Exams + Lessons (4 obserations) Perform feature selection with lasso regression. Run a lasso regression using the code chunk provided. The code will need to be modified to reflect your decision in Task 7 regarding the PCA variable. You probably read this and asked “what is a lasso regression?” and with good reason - we haven’t yet covered this topic. All that you need to know is highlighted in black: you will need to change the code that they give you, which is below. You need to choose between using one of two data sets: DATA SET A DATA SET B Then ignore everything else! # Format data as matrices (necessary for glmnet). # Uncomment two items that reflect your decision from Task 7. #DATA SET A lasso.mat.train &lt;- model.matrix(days ~ . - PC1, data.train) lasso.mat.test &lt;- model.matrix(days ~ . - PC1, data.test) #DATA SET B # lasso.mat.train &lt;- model.matrix(days ~ . - num_procs - num_meds - num_ip - num_diags, data.train) # lasso.mat.test &lt;- model.matrix(days ~ . - num_procs - num_meds - num_ip - num_diags, data.test) set.seed(789) lasso.cv &lt;- cv.glmnet( x = lasso.mat.train, y = data.train$days, family = &quot;poisson&quot;, # Do not change. alpha = 1 # alpha = 1 for lasso ) If you wanted to use data set B, you would just add comments to data set A and uncomment B. #DATA SET A # lasso.mat.train &lt;- model.matrix(days ~ . - PC1, data.train) # lasso.mat.test &lt;- model.matrix(days ~ . - PC1, data.test) #DATA SET B lasso.mat.train &lt;- model.matrix(days ~ . - num_procs - num_meds - num_ip - num_diags, data.train) lasso.mat.test &lt;- model.matrix(days ~ . - num_procs - num_meds - num_ip - num_diags, data.test) 2.3 Example 2 - Data exploration That last example was easy. They might ask you to do something like the following: Template code: # This code takes a continuous variable and creates a binned factor variable. # The code applies it directly to the capital gain variable as an # example. right = FALSE means that the left number is included and # the right number excluded. So, in this case, the first bin runs from 0 to # 1000 and includes 0 and excludes 1000. Note that the code creates a new # variable, so the original variable is retained. df$cap_gain_cut &lt;- cut(df$cap_gain, breaks = c(0, 1000, 5000, Inf), right = FALSE, labels = c(&quot;lowcg&quot;, &quot;mediumcg&quot;, &quot;highcg&quot;)) To answer this question correctly, you would need to Understand that the code is taking the capital gains recorded on investments, cap_gain, and then creating bins so that the new variable is “lowcg” for values between 0 and 1000, “mediumcp” from 1000 to 5000, and “highcg” for all values above 5000. Then you would need to interpret a statistical model Finally, use this result to change these cutoff values so that “low cg” is all values less than 5095.5, “medium cg” is all values from 5095.5 to 7055.5, and so forth. You would need to do this for two data sets, data.train, and data.test. Solution code: # This code cuts a continuous variable into buckets. # The process is applied to both the training and test sets. data.train$cap_gain_cut &lt;- cut(data.train$cap_gain, breaks = c(0, 5095.5, 7055.5, Inf), right = FALSE, labels = c(&quot;lowcg&quot;, &quot;mediumcg&quot;, &quot;highcg&quot;)) data.test$cap_gain_cut &lt;- cut(data.test$cap_gain, breaks = c(0, 5095.5, 7055.5, Inf), right = FALSE, labels = c(&quot;lowcg&quot;, &quot;mediumcg&quot;, &quot;highcg&quot;)) Do not panic if all of this code is confusing. Just focus on reading the comments. As you can see, this is less of a programming question than it is a “logic and reasoning” question. "],["r-programming.html", " 3 R programming 3.1 Notebook chunks 3.2 Basic operations 3.3 Lists 3.4 Functions 3.5 Data frames", " 3 R programming This chapter teaches you the R skills that are needed to pass PA. 3.1 Notebook chunks On the Exam, you will start with an .Rmd (R Markdown) template, which organize code into R Notebooks. Within each notebook, code is organized into chunks. # This is a chunk Your time is valuable. Throughout this book, I will include useful keyboard shortcuts. Shortcut: To run everything in a chunk quickly, press CTRL + SHIFT + ENTER. To create a new chunk, use CTRL + ALT + I. 3.2 Basic operations The usual math operations apply. # Addition 1 + 2 ## [1] 3 3 - 2 ## [1] 1 # Multiplication 2 * 2 ## [1] 4 # Division 4 / 2 ## [1] 2 # Exponentiation 2^3 ## [1] 8 There are two assignment operators: = and &lt;-. The latter is preferred because it is specific to assigning a variable to a value. The = operator is also used for specifying arguments in functions (see the functions section). Shortcut: ALT + - creates a &lt;-.. # Variable assignment y &lt;- 2 # Equality 4 == 2 ## [1] FALSE 5 == 5 ## [1] TRUE 3.14 &gt; 3 ## [1] TRUE 3.14 &gt;= 3 ## [1] TRUE Vectors can be added just like numbers. The c stands for “concatenate,” which creates vectors. x &lt;- c(1, 2) y &lt;- c(3, 4) x + y ## [1] 4 6 x * y ## [1] 3 8 z &lt;- x + y z^2 ## [1] 16 36 z / 2 ## [1] 2 3 z + 3 ## [1] 7 9 I already mentioned numeric types. There are also character (string) types, factor types, and boolean types. character &lt;- &quot;The&quot; character_vector &lt;- c(&quot;The&quot;, &quot;Quick&quot;) Character vectors can be combined with the paste() function. a &lt;- &quot;The&quot; b &lt;- &quot;Quick&quot; c &lt;- &quot;Brown&quot; d &lt;- &quot;Fox&quot; paste(a, b, c, d) ## [1] &quot;The Quick Brown Fox&quot; Factors look like character vectors but can only contain a finite number of predefined values. The below factor has only one “level,” which is the list of assigned values. factor &lt;- as.factor(character) levels(factor) ## [1] &quot;The&quot; The levels of a factor are by default in R in alphabetical order (Q comes alphabetically before T). factor_vector &lt;- as.factor(character_vector) levels(factor_vector) ## [1] &quot;Quick&quot; &quot;The&quot; In building linear models, the order of the factors matters. In GLMs, the “reference level” or “base level” should always be the level which has the most observations. This will be covered in the section on linear models. Booleans are just TRUE and FALSE values. R understands T or TRUE in the same way, but the latter is preferred. When doing math, bools are converted to 0/1 values where 1 is equivalent to TRUE and 0 FALSE. bool_true &lt;- TRUE bool_false &lt;- FALSE bool_true * bool_false ## [1] 0 Booleans are automatically converted into 0/1 values when there is a math operation. bool_true + 1 ## [1] 2 Vectors work in the same way. bool_vect &lt;- c(TRUE, TRUE, FALSE) sum(bool_vect) ## [1] 2 Vectors are indexed using [. If you are only extracting a single element, you should use [[ for clarity. abc &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) abc[[1]] ## [1] &quot;a&quot; abc[[2]] ## [1] &quot;b&quot; abc[c(1, 3)] ## [1] &quot;a&quot; &quot;c&quot; abc[c(1, 2)] ## [1] &quot;a&quot; &quot;b&quot; abc[-2] ## [1] &quot;a&quot; &quot;c&quot; abc[-c(2, 3)] ## [1] &quot;a&quot; 3.3 Lists Lists are vectors that can hold mixed object types. my_list &lt;- list(TRUE, &quot;Character&quot;, 3.14) my_list ## [[1]] ## [1] TRUE ## ## [[2]] ## [1] &quot;Character&quot; ## ## [[3]] ## [1] 3.14 Lists can be named. my_list &lt;- list(bool = TRUE, character = &quot;character&quot;, numeric = 3.14) my_list ## $bool ## [1] TRUE ## ## $character ## [1] &quot;character&quot; ## ## $numeric ## [1] 3.14 The $ operator indexes lists. my_list$numeric ## [1] 3.14 my_list$numeric + 5 ## [1] 8.14 Lists can also be indexed using [[. my_list[[1]] ## [1] TRUE my_list[[2]] ## [1] &quot;character&quot; Lists can contain vectors, other lists, and any other object. everything &lt;- list(vector = c(1, 2, 3), character = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), list = my_list) everything ## $vector ## [1] 1 2 3 ## ## $character ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; ## ## $list ## $list$bool ## [1] TRUE ## ## $list$character ## [1] &quot;character&quot; ## ## $list$numeric ## [1] 3.14 To find out the type of an object, use class or str or summary. class(x) ## [1] &quot;numeric&quot; class(everything) ## [1] &quot;list&quot; str(everything) ## List of 3 ## $ vector : num [1:3] 1 2 3 ## $ character: chr [1:3] &quot;a&quot; &quot;b&quot; &quot;c&quot; ## $ list :List of 3 ## ..$ bool : logi TRUE ## ..$ character: chr &quot;character&quot; ## ..$ numeric : num 3.14 summary(everything) ## Length Class Mode ## vector 3 -none- numeric ## character 3 -none- character ## list 3 -none- list 3.4 Functions You only need to understand the very basics of functions. The big picture is that understanding functions help you to understand everything in R, since R is a functional programming language, unlike Python, C, VBA, Java, all object-oriented, or SQL, which is not a language but a series of set-operations. Functions do things. The convention is to name a function as a verb. The function make_rainbows() would create a rainbow. The function summarise_vectors() would summarise vectors. Functions may or may not have an input and output. If you need to do something in R, there is a high probability that someone has already written a function to do it. That being said, creating simple functions is quite helpful. Here is an example that has a side effect of printing the input: greet_me &lt;- function(my_name){ print(paste0(&quot;Hello, &quot;, my_name)) } greet_me(&quot;Future Actuary&quot;) ## [1] &quot;Hello, Future Actuary&quot; A function that returns something When returning the last evaluated expression, the return statement is optional. In fact, it is discouraged by convention. add_together &lt;- function(x, y) { x + y } add_together(2, 5) ## [1] 7 add_together &lt;- function(x, y) { # Works, but bad practice return(x + y) } add_together(2, 5) ## [1] 7 Binary operations in R are vectorized. In other words, they are applied element-wise. x_vector &lt;- c(1, 2, 3) y_vector &lt;- c(4, 5, 6) add_together(x_vector, y_vector) ## [1] 5 7 9 Many functions in R actually return lists! This is why R objects can be indexed with dollar sign. library(ExamPAData) model &lt;- lm(charges ~ age, data = health_insurance) model$coefficients ## (Intercept) age ## 3165.8850 257.7226 Here’s a function that returns a list. sum_multiply &lt;- function(x,y) { sum &lt;- x + y product &lt;- x * y list(&quot;Sum&quot; = sum, &quot;Product&quot; = product) } result &lt;- sum_multiply(2, 3) result$Sum ## [1] 5 result$Product ## [1] 6 3.5 Data frames You can think of a data frame as a table that is implemented as a list of vectors. df &lt;- data.frame( age = c(25, 35), has_fsa = c(FALSE, TRUE) ) df ## age has_fsa ## 1 25 FALSE ## 2 35 TRUE To index columns in a data frame, the same “$” is used as indexing a list. df$age ## [1] 25 35 To find the number of rows and columns, use dim. dim(df) ## [1] 2 2 To find a summary, use summary summary(df) ## age has_fsa ## Min. :25.0 Mode :logical ## 1st Qu.:27.5 FALSE:1 ## Median :30.0 TRUE :1 ## Mean :30.0 ## 3rd Qu.:32.5 ## Max. :35.0 "]]
